//******************************************************************************************************
// AccountService.java
//
// Service for account according to redfish.
//
//Copyright (C) 2022, PICMG.
//
//        This program is free software: you can redistribute it and/or modify
//        it under the terms of the GNU General Public License as published by
//        the Free Software Foundation, either version 3 of the License, or
//        (at your option) any later version.
//
//        This program is distributed in the hope that it will be useful,
//        but WITHOUT ANY WARRANTY; without even the implied warranty of
//        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//        GNU General Public License for more details.
//
//        You should have received a copy of the GNU General Public License
//        along with this program.  If not, see <https://www.gnu.org/licenses/>.
//*******************************************************************************************************


package org.picmg.redfish_server_template.services;

import org.picmg.redfish_server_template.RFmodels.Autogenerated.RedfishError;
import org.picmg.redfish_server_template.RFmodels.Autogenerated.Task_TaskState;
import org.picmg.redfish_server_template.RFmodels.custom.RedfishObject;
import org.picmg.redfish_server_template.repository.RedfishObjectRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.data.crossstore.ChangeSetPersister;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.util.*;
import java.util.concurrent.Future;

@Service
public class AccountService {
    public class PasswordStats {
        public LocalTime lastFailedAttempt;
        public long lockoutCounter = 0;
        public long failsUntilLog = 0;
    }

    @Value("${async.task.wait-time}")
    long taskWaitTime;

    @Autowired
    RedfishObjectRepository objectRepository;

    @Autowired
    TaskService taskService;

    @Autowired
    SchemaService schemaService;

    @Autowired
    PasswordEncoder passwordEncoder;

    @Autowired
    RedfishErrorResponseService errorResponseService;
    @Autowired
    LogService logService;

    private boolean requireChangePasswordAction = false;
    private long accountLockoutCounterResetAfter = 0;
    private boolean accountLockoutCounterResetEnabled = false;
    private long accountLockoutDuration = 0;
    private long accountLockoutThreshold = 0;
    private long authFailureLoggingThreshold = 0;

    private long passwordExpirationDays = 0;

    private HashMap<String, PasswordStats> pwStatCollection = new HashMap<>();


    @PostConstruct
    public void configure() throws Exception {
        // start the account service, adding an admin account if there are no other accounts
        if (!doAccountsExist()) {
            addAdministratorAccount("test");
        }

        // initialize account service operation
        List<String> resultslist = objectRepository.getDistinctStringsWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"RequireChangePasswordAction");
        if ((resultslist!=null)&&(!resultslist.isEmpty())) {
            if (resultslist.get(0).toLowerCase().equals("true")) requireChangePasswordAction = true;
        }
        List<Long> llist = objectRepository.getDistinctLongWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"AccountLockoutCounterResetAfter");
        if ((llist!=null)&&(!llist.isEmpty())) accountLockoutCounterResetAfter = llist.get(0);
        List<Boolean> blist = objectRepository.getDistinctBooleanWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"AccountLockoutCounterResetEnabled");
        if ((blist!=null)&&(!blist.isEmpty())) accountLockoutCounterResetEnabled = blist.get(0);
        llist = objectRepository.getDistinctLongWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"AccountLockoutDuration");
        if ((llist!=null)&&(!llist.isEmpty())) accountLockoutDuration = llist.get(0);
        llist = objectRepository.getDistinctLongWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"AccountLockoutThreshold");
        if ((llist!=null)&&(!llist.isEmpty())) accountLockoutThreshold = llist.get(0);
        llist = objectRepository.getDistinctLongWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"AuthFailureLoggingThreshold");
        if ((llist!=null)&&(!llist.isEmpty())) authFailureLoggingThreshold = llist.get(0);
        llist = objectRepository.getDistinctLongWithQuery("RedfishObject", Criteria.where("_odata_type").is("AccountService"),"PasswordExpirationDays");
        if ((llist!=null)&&(!llist.isEmpty())) passwordExpirationDays = llist.get(0);
    }

    public boolean isChangePasswordActionRequired() { return requireChangePasswordAction; }

    @Async
    //  This method assumes that the account parameter holds a valid account Redfish object
    //
    public Future<Boolean> updateUser(OffsetDateTime startTime, Integer taskId, RedfishObject account) throws  Exception {
        List<RedfishObject> userAccounts = objectRepository.findWithQuery(
                Criteria.where("_odata_type").is("ManagerAccount")
                        .and("UserName").is(account.get("UserName").toString()));
        try {
            if (userAccounts.isEmpty())
                throw new ChangeSetPersister.NotFoundException();
            if (userAccounts.size()>1)
                throw new ChangeSetPersister.NotFoundException();
            RedfishObject userAccount = userAccounts.get(0);
            if(!account.getName().isEmpty())
                userAccount.setName(account.get("UserName").toString());
            if(!account.getDescription().isEmpty())
                userAccount.setDescription(account.get("Description").toString());
            if(account.containsKey("Password")) {
                String encPassword = passwordEncoder.encode(account.get("Password").toString());
                userAccount.put("Password",encPassword);
            }
            if(account.containsKey("Enabled"))
                userAccount.put("Enabled",account.get("Enabled"));
            if(account.containsKey("RoleId"))
                userAccount.put("RoleId",account.get("RoleId"));
            if(account.containsKey("Locked"))
                userAccount.put("Locked",account.get("Locked"));

            // DEBUG: System.out.println("Async Account Service Complete");
            objectRepository.save(userAccount);
            if(startTime.getSecond() > taskWaitTime+1) {
                taskService.updateTaskState(taskId.toString(), Task_TaskState.COMPLETED, userAccount);
            }
        } catch (Exception e) {
            throw new Exception("Error While Updating Account");
        }
        return new AsyncResult<Boolean>(true);
    }

    // this function is called after all checks for patch of password and passwordChange actions have passed.
    // Encode and store the password and update all password-related statistics
    //
    // returns true if the password was updated, otherwise, returns false.
    public boolean updatePassword(String userName, String password)  {
        RedfishObject userAccount = objectRepository.findFirstWithQuery(
                Criteria.where("_odata_type").is("ManagerAccount")
                        .and("UserName").is(userName));
        if (userAccount == null) return false;
        String encPassword = passwordEncoder.encode(password);

        // is the password changed?
        if (pwStatCollection.containsKey(userName)) pwStatCollection.remove(userName);
        if (passwordEncoder.matches(password,userAccount.get("Password").toString())) {
            return false;
        } else {
            Update update = new Update();
            if (passwordExpirationDays != 0) {
                update.set("PasswordExpiration", LocalDateTime.now().plusDays(passwordExpirationDays));
            }
            update.set("Password", encPassword);
            if (userAccount.containsKey("Locked"))
                update.set("Locked", false);
            if (userAccount.containsKey("PasswordChangeRequired"))
                update.set("PasswordChangeRequired", false);
            objectRepository.findAndUpdate(
                    Criteria.where("_odata_type").is("ManagerAccount")
                    .and("UserName").is(userName), update);
        }
        return true;
    }

    public Boolean deleteAccount(RedfishObject account) throws ChangeSetPersister.NotFoundException {
        List<RedfishObject> userAccounts = objectRepository.findWithQuery(
                Criteria.where("_odata_type").is("ManagerAccount")
                        .and("UserName").is(account.get("UserName").toString()));
        if (userAccounts.isEmpty())
            throw new ChangeSetPersister.NotFoundException();
        if (userAccounts.size()>1)
            throw new ChangeSetPersister.NotFoundException();

        objectRepository.delete(userAccounts.get(0));
        return true;
    }

    public void addAdministratorAccount(String password) throws Exception {
        RedfishObject account = new RedfishObject();
        List<RedfishObject> userAccounts = objectRepository.findWithQuery(
                Criteria.where("_odata_type").is("ManagerAccount")
                        .and("UserName").is("Administrator"));
        if (!userAccounts.isEmpty())
            throw new Exception("UserName Administrator Already Exists");

        List<RedfishObject> listAccount = objectRepository.findWithQuery(
                Criteria.where("_odata_type").is("ManagerAccount"));
        if(listAccount.isEmpty()) {
            account.setId("1");
            account.setAtOdataId("/redfish/v1/AccountService/Accounts/1");
        } else {
            long max = 0;
            for(RedfishObject account1 : listAccount){
                max = Math.max(max, Long.parseLong(account1.getId()));
            }
            max++;
            account.setId(max+"");
            account.setAtOdataId("/redfish/v1/AccountService/Accounts/"+max);
        }
        String encPassword = passwordEncoder.encode(password);
        account.put("Password",encPassword);
        account.put("AccountTypes", Collections.singletonList("Redfish"));
        // use the most recent version of the schema
        String schemaVersion = "#"+schemaService.getNewestVersionFromType("ManagerAccount").getSource();
        schemaVersion = schemaVersion.replace(".json",".ManagerAccount");
        account.setAtOdataType(schemaVersion);
        account.put("Name","Administrator Account");
        account.put("UserName","Administrator");
        account.put("Enabled",true);
        account.put("Locked",false);
        account.put("RoleId","Administrator");
        account.put("Links", Collections.singletonMap(
                "Role", Collections.singletonMap(
                        "@odata.id","/redfish/v1/AccountService/Roles/Administrator")));
        objectRepository.save(account);
    }

    public List<String> getRoles() {
        List<String> result = new ArrayList<>();

        // get a list of all the roles available
        List<RedfishObject> roleObjects = objectRepository.findWithQuery(
                Criteria.where("_odata_type").is("Role"));
        if (roleObjects.isEmpty()) return result;

        // compose a list of roleIds from the list
        for (RedfishObject obj: roleObjects) {
            if (obj.containsKey("Id")) result.add(obj.get("Id").toString());
        }

        return result;
    }


    public RedfishObject getAccountFromUserName(String userName) {
        return objectRepository.findFirstWithQuery(Criteria.where("_odata_type").is("ManagerAccount").and("UserName").is(userName));
    }

    public boolean doAccountsExist() {
        return !objectRepository.findWithQuery(Criteria.where("_odata_type").is("ManagerAccount")).isEmpty();
    }

    private void unlockAccount(String odataid) {
        objectRepository.findAndUpdate(Criteria.where("_odata_id").is(odataid), Update.update("Locked",false));
    }

    private void lockAccount(String odataid) {
        objectRepository.findAndUpdate(Criteria.where("_odata_id").is(odataid), Update.update("Locked",true));
    }

    private boolean isPasswordChangeRequired(RedfishObject account) {
        if ((account.getBoolean("PasswordChangeRequired",false)||(account.containsKey("PasswordExpiration"))&&(account.get("PasswordExpiration")!=null))) {
            LocalDateTime expiration = LocalDateTime.parse(account.getString("PasswordExpiration"));
            if (expiration.isBefore(LocalDateTime.now())) {
                // the password has expired.
                objectRepository.findAndUpdate(Criteria.where("_odata_id").is(account.getAtOdataId()), Update.update("PasswordChangeRequired",true));
                return true;
            }
        }
        return account.getBoolean("PasswordChangeRequired",false);
    }

    // validate the username/password against the user account.  Update statistics if the password is incorrect.
    // return false if the password is wrong, the account is locked, or a password change is required.
    //
    // if the password validates okay or with restrictions, this function returns null
    public RedfishError validatePasswordAgainstAccount(String username, String password, HttpServletRequest req) {
        RedfishObject account = objectRepository.findFirstWithQuery(
                Criteria.where("_odata_type").is("ManagerAccount").and("UserName").is(username));

        if ((account == null)||(!account.getBoolean("Enabled", true)))  {
            // account does not exist or is not enabled
            return errorResponseService.getErrorMessage("Base","AccessDenied",
                    List.of(req.getRequestURI()), List.of());
        }

        // update password stats based on current time
        boolean accountLocked = account.getBoolean("Locked",false);
        if ((pwStatCollection.containsKey(username))) {
            PasswordStats stats = pwStatCollection.get(username);
            Duration timesincelastfail = Duration.between(stats.lastFailedAttempt,LocalTime.now());
            if ((accountLockoutCounterResetEnabled)&&(timesincelastfail.toSeconds() > accountLockoutCounterResetAfter)) {
                stats.lockoutCounter = 0;
            }
            if ((timesincelastfail.toSeconds() > accountLockoutDuration)&&(account.getBoolean("Locked", false))) {
                // if the account is locked out, it should be updated now.
                unlockAccount(account.getAtOdataId());
                account.put("Locked",false);
            }
            pwStatCollection.put(username,stats);
        }

        // if the account is locked out, no attempts can be made for logging in
        if (account.getBoolean("Locked",false)) {
            return errorResponseService.getErrorMessage("Base","AccessDenied",
                    List.of(req.getRequestURI()), List.of());
        }

        // does the password match
        if (!passwordEncoder.matches(password,account.getString("Password"))) {
            // update the lockout statistics
            PasswordStats failStats  = new PasswordStats();
            if (pwStatCollection.containsKey(username)) {
                failStats  = pwStatCollection.get(username);
            } else {
                failStats.lockoutCounter = 0;
                failStats.failsUntilLog = 0;
            }
            failStats.lastFailedAttempt = LocalTime.now();
            failStats.lockoutCounter++;
            failStats.failsUntilLog++;
            if (failStats.lockoutCounter>accountLockoutThreshold) {
                if (!account.getBoolean("Locked",false)) lockAccount(account.getAtOdataId());
                if (failStats.failsUntilLog>=authFailureLoggingThreshold) {
                    failStats.failsUntilLog = 0;
                    // Todo send the log
                }
            }
            pwStatCollection.put(username,failStats);
            return errorResponseService.getErrorMessage("Base","AccessDenied",
                    List.of(req.getRequestURI()), List.of());
        }

        // here if the password matches
        pwStatCollection.remove(username);

        // see if the password has expired
        if (isPasswordChangeRequired(account)) {
            String requri = req.getRequestURI();
            String actionBase = "";
            String actionName = "";
            RedfishObject referencedResource = objectRepository.findFirstWithQuery(Criteria.where("_odata_id").is(requri));
            if (requri.contains("/Actions/")) {
                actionBase = requri.substring(0, requri.indexOf("/Actions/"));
                actionName = requri.substring(requri.lastIndexOf('.')+1);
            }

            // there are very few actions that are allowed with password change required.  According to the
            // redfish specification, these are:

            // A session login
            if ((req.getMethod().equals("POST"))&&(requri.matches("^/redfish/v1/SessionService/[^\\/]+$"))) {}
            // A GET operation on the ManagerAccount resource associated with the account.
            else if ((req.getMethod().equals("GET"))&&(account.getAtOdataId().equals(requri))) {}
            // A PATCH operation on the ManagerAccount to change the PW (RequireChangePasswordAction=false)
            else if ((req.getMethod().equals("PATCH"))&&(account.getAtOdataId().equals(requri))&&(!requireChangePasswordAction)) {}
            // A POST operation on the ChangePassword action
            else if ((req.getMethod().equals("POST"))&&(account.getAtOdataId().equals(actionBase))&&(actionName.equals("ChangePassword"))) {}
            // A DELETE operation on Session resources representing open sessions associated with the account.
            else if ((req.getMethod().equals("DELETE"))&&
                    (referencedResource != null) && (referencedResource.getAtOdataType().equals("Session")) &&
                    (referencedResource.containsKey("UserName"))&&(referencedResource.getString("UserName").equals(username))) {
            } else {
                // access denied
                return errorResponseService.getErrorMessage("Base","AccessDenied",
                        List.of(requri), List.of());
            }
        }
        return null;
    }
}
