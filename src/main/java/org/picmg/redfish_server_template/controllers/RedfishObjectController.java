package org.picmg.redfish_server_template.controllers;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.models.Response;
import org.bson.Document;
import org.picmg.redfish_server_template.RFmodels.Autogenerated.RedfishError;
import org.picmg.redfish_server_template.RFmodels.custom.CachedSchema;
import org.picmg.redfish_server_template.RFmodels.custom.RedfishCollection;
import org.picmg.redfish_server_template.RFmodels.custom.RedfishObject;
import org.picmg.redfish_server_template.data_validation.ValidRedfishObject;
import org.picmg.redfish_server_template.repository.RedfishObjectRepository;
import org.picmg.redfish_server_template.services.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.time.OffsetDateTime;
import java.util.*;
import java.util.concurrent.*;

import static java.lang.Thread.sleep;

// this is the highest level redfish object handler.  All pages are derived from it
// so the Request mapping is for all matches **.  The wildcard uri is resolved so that more specific
// uris will take precedence over a wildcard match.  So controllers derived from this can override the path with
// a more specific value.
@RestController
@RequestMapping(value = {"/redfish/v1/**"})
public class RedfishObjectController {
    static protected HashMap<String,Future<ResponseEntity<?>>> taskList = new HashMap<>();
    @Autowired
    RedfishObjectRepository objectRepository;

    @Autowired
    RedfishErrorResponseService redfishErrorResponseService;

    @Autowired
    SchemaService schemaService;

    @Autowired
    PrivilegeTableService privilegeTableService;

    @Autowired
    TaskService taskService;

    @GetMapping(value="")
    public ResponseEntity<?> get(HttpServletRequest request) {
        // get the database entry associated with this path
        String uri = request.getRequestURI();
        RedfishObject entity = objectRepository.findFirstWithQuery(Criteria
                .where("_odata_id").is(uri));

        if (entity == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("");
        }

        // the entity must include the @odata.type field.  Check to see if it includes "Collection" in the name
        if (!entity.containsKey("@odata.type")) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("");
        }

        if (entity instanceof RedfishCollection) {
            return processCollectionGet((RedfishCollection) entity, request);
        }
        return processObjectGet(entity, request);
    }

    private void nullWriteOnlyHelper(Map<String,Object> map, String schemaReference, String field) {
        for (String key: map.keySet()) {
            Object obj = map.get(key);
            String newField = field;
            if (newField.isEmpty()) {
                newField = key;
            } else {
                newField = newField+"/"+key;
            }
            if (obj instanceof Map) {
                // recurse to take care of this object
                //noinspection unchecked
                nullWriteOnlyHelper((Map<String,Object>)obj, schemaReference, newField);

            } else if (obj instanceof List) {
                // if the entire list is write-only, then null all the items
                if (schemaService.isSchemaFieldWriteOnly(schemaReference,newField)) {
                    //noinspection unchecked
                    Collections.fill(((List<Object>) obj), null);
                } else {
                    // the list is not write-only, but elements of it might be
                    //noinspection unchecked
                    for (Object element : (List<Object>) obj) {
                        if (element instanceof Map)
                            // recurse to take care of this object - the elements should be complex
                            //noinspection unchecked
                            nullWriteOnlyHelper((Map<String,Object>)element, schemaReference, newField);
                    }
                }
            } else {
                // otherwise, this is a simple object - apply the property for the object
                if (schemaService.isSchemaFieldWriteOnly(schemaReference,newField)) {
                    map.put(key,null);
                }
            }
        }
    }

    private void nullWriteOnlyValues(RedfishObject entity) {
        // Create the schema reference from the entity information
        String ref = entity.get("@odata.type").toString();
        ref = ref.replace("#","");
        int pos = ref.lastIndexOf('.');
        String schemaFilePart = ref.substring(0,pos);
        String fragmentPart = ref.substring(pos+1);
        String schemaReference = schemaFilePart+".json#/definitions/"+fragmentPart;

        String field = "";
        nullWriteOnlyHelper(entity, schemaReference, field);
    }

    private List<RedfishError> removeReadOnlyHelper(Map<String,Object> map, String schemaReference, String field) {
        ArrayList<RedfishError> result = new ArrayList<>();

        Iterator<Map.Entry<String,Object>> it = map.entrySet().iterator();
        while (it.hasNext ()) {
            Map.Entry<String,Object> entry = it.next();
            String key = entry.getKey();
            Object obj = entry.getValue();
            String newField = field;
            if (newField.isEmpty()) {
                newField = key;
            } else {
                newField = newField+"/"+key;
            }
            if (obj instanceof Map) {
                // recurse to take care of this object
                @SuppressWarnings("unchecked") List<RedfishError> partial = removeReadOnlyHelper((Map<String,Object>)obj, schemaReference, newField);
                result.addAll(partial);
                if (!partial.isEmpty()) it.remove();

            } else if (obj instanceof List) {
                // if the entire list is write-only, then null all the items
                if (schemaService.isSchemaFieldReadOnly(schemaReference,newField)) {
                    @SuppressWarnings("unchecked") Iterator<Object> lItr = ((List<Object>)obj).iterator();
                    while (lItr.hasNext()) {
                        lItr.next();
                        // Property is not writable - remove it from the list
                        RedfishError error = redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "PropertyNotWritable",
                                Collections.singletonList(newField),
                                new ArrayList<>());
                        result.add(error);
                        lItr.remove();
                    }
                    //noinspection unchecked
                    if (((List<Object>) obj).isEmpty()) {
                        it.remove();
                    }
                } else {
                    // Objects in the list may be written only if they are objects
                    @SuppressWarnings("unchecked") Iterator<Object> lItr = ((List<Object>)obj).iterator();
                    while (lItr.hasNext()) {
                        Object element = lItr.next();
                        // recurse to take care of this object - the elements should be complex
                        if (element instanceof Map) {
                            @SuppressWarnings("unchecked") List<RedfishError> partial = removeReadOnlyHelper((Map<String,Object>)element, schemaReference, newField);
                            result.addAll(partial);
                            if (!partial.isEmpty()) lItr.remove();
                        }
                    }
                    //noinspection unchecked
                    if (((List<Object>) obj).isEmpty()) {
                        it.remove();
                    }
                }
            } else {
                // otherwise, this is a simple object - apply the property for the object
                if (schemaService.isSchemaFieldReadOnly(schemaReference,newField)) {
                    // Property not writable, remove it from the object
                    // don't give an error for @odata.type - this may have been added by the data validation filter
                    if (!newField.equals("@odata.type")) {
                        RedfishError error = redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "PropertyNotWritable",
                                Collections.singletonList(newField),
                                new ArrayList<>());
                        result.add(error);
                    }
                    it.remove();
                }
            }
        }
        return result;
    }

    private List<RedfishError> removeReadOnlyValues(RedfishObject entity) {
        // Create the schema reference from the entity information
        String ref = entity.get("@odata.type").toString();
        ref = ref.replace("#","");
        int pos = ref.lastIndexOf('.');
        String schemaFilePart = ref.substring(0,pos);
        String fragmentPart = ref.substring(pos+1);
        String schemaReference = schemaFilePart+".json#/definitions/"+fragmentPart;

        String field = "";
        return removeReadOnlyHelper(entity, schemaReference, field);
    }

    public ResponseEntity<?> processObjectGet(RedfishObject entity, HttpServletRequest request) {
        String ifMatch = request.getHeader("If-Match");
        String ifNoneMatch = request.getHeader("If-None-Match");
        if (ifMatch!=null) {
            ifMatch = ifMatch.replace("\"", "");
            if ((!ifMatch.equals("*")) && (!entity.getAtOdataEtag().equals(ifMatch))) {
                // here if the precondition was not met
                return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).body("");
            }
        }
        if (ifNoneMatch!=null) {
            ifNoneMatch = ifNoneMatch.replace("\"", "");
            if ((ifNoneMatch.equals("*"))||(entity.getAtOdataEtag().equals(ifNoneMatch))) {
                // the precondition failed - there should be no matches for this to proceed.
                return ResponseEntity.status(HttpStatus.NOT_MODIFIED).body("");
            }
        }

        // Check parameters for unknown or unsupported parameters
        Map<String,String[]> parameters = request.getParameterMap();
        ArrayList<String> unknownParameters = new ArrayList<>();
        boolean excerpt = false;
        for (Map.Entry<String,String[]> parameter: parameters.entrySet()) {
            String key = parameter.getKey();
            if (key.startsWith("$")) {
                switch (key) {
                    case "$top":
                    case "$skip":
                        // REQ: Shall return HTTP 400 bad request status code for any query parameters
                        // that contain values that are invalid or values applied to the query parameters
                        // without defined values, such as excerpt, only
                        if (parameter.getValue().length != 1 ||
                                (!Helpers.isInteger(parameter.getValue()[0])) ||
                                (Integer.parseInt(parameter.getValue()[0]) < 0)) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("");
                        }
                        // ignore top for non collections
                        // ignore skip for non-collections
                        break;
                    default:
                        // REQ: may support $expand, $filter, and $select query parameters
                        unknownParameters.add(key);
                        break;
                }
            } else {
                switch(key) {
                    case "excerpt":
                    case "only":
                        // REQ: Shall return HTTP 400 bad request status code for any query parameters
                        // that contain values that are invalid or values applied to the query parameters
                        // without defined values, such as excerpt, only
                        if ((parameter.getValue().length != 1) || (!parameter.getValue()[0].isEmpty())) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Bad Request");
                        }
                        if (key.equals("excerpt")) excerpt = true;
                        break;
                    default:
                        // REQ: Shall ignore unknown or unsupported query parameters that
                        // do not begin with $
                        break;
                }
            }
        }
        if (!unknownParameters.isEmpty()) {
            // REQ: shall return a 501 not implemented status code for any unsupported
            // query parameters that start with $.  An extended error that
            // indicates unsupported query parameters for this resource
            RedfishError error = redfishErrorResponseService.getErrorMessage(
                    "Base","QueryNotSupported",new ArrayList<>(), new ArrayList<>());
            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(error);
        }

        if ((parameters.containsKey("only"))&&(parameters.entrySet().size()>1)) {
            // REQ: Services should return the HTTP 400 Bad Request with the QueryCombinationInvalid message from the
            // base message registry if 'only' is being combined with other query parameters.
            RedfishError error = redfishErrorResponseService.getErrorMessage(
                    "Base","QueryCombinationInvalid",new ArrayList<>(), new ArrayList<>());
            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(error);
        }

        // Convert the entity to a json object and prepare it to send in response body
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        String json = "{}";
        // remove any keys that start with underscore character
        entity.remove("_odata_id");
        entity.remove("_odata_type");
        entity.remove("_id");
        String etag = entity.getAtOdataEtag();
        entity.put("@odata.etag",etag);
        entity.remove("_odata_etag");
        // Replace any write-only content with nulls
        nullWriteOnlyValues(entity);

        try {
            json = mapper.writeValueAsString(entity);
        } catch (Exception ignored) {
        }

        // here if the request is valid - convert the POJO to a clean JSON string and return the results
        // within the body of the HTTP response.
        return ResponseEntity.ok().eTag(etag).contentType(MediaType.APPLICATION_JSON).body(json);
    }

    public ResponseEntity<?> processCollectionGet(RedfishCollection entity, HttpServletRequest request) {
        String ifMatch = request.getHeader("If-Match");
        String ifNoneMatch = request.getHeader("If-None-Match");
        if (ifMatch!=null) {
            ifMatch = ifMatch.replace("\"", "");
            if ((!ifMatch.equals("*")) && (!entity.getAtOdataEtag().equals(ifMatch))) {
                // here if the precondition was not met
                return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).body("");
            }
        }
        if (ifNoneMatch!=null) {
            ifNoneMatch = ifNoneMatch.replace("\"", "");
            if ((ifNoneMatch.equals("*"))||(entity.getAtOdataEtag().equals(ifNoneMatch))) {
                // the precondition failed - there should be no matches for this to proceed.
                return ResponseEntity.status(HttpStatus.NOT_MODIFIED).body("");
            }
        }

        // get the database entry associated with this path
        String uri = request.getRequestURI();

        // Check parameters for unknown or unsupported parameters
        Map<String,String[]> parameters = request.getParameterMap();
        ArrayList<String> unknownParameters = new ArrayList<>();
        int top = entity.getMembersAtOdataCount();
        int skip = 0;
        boolean excerpt = false;
        boolean only = false;
        for (Map.Entry<String,String[]> parameter: parameters.entrySet()) {
            String key = parameter.getKey();
            if (key.startsWith("$")) {
                switch (key) {
                    case "$top":
                    case "$skip":
                        // REQ: Shall return HTTP 400 bad request status code for any query parameters
                        // that contain values that are invalid or values applied to the query parameters
                        // without defined values, such as excerpt, only
                        if (parameter.getValue().length != 1 ||
                                (!Helpers.isInteger(parameter.getValue()[0])) ||
                                (Integer.parseInt(parameter.getValue()[0]) < 0)) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("");
                        }
                        if (key.equals("$top")) {
                            top = Integer.parseInt((parameter.getValue()[0]));
                            if (top > entity.getMembersAtOdataCount())
                                top = entity.getMembersAtOdataCount();
                        }
                        if (key.equals("$skip")) {
                            skip = Integer.parseInt(parameter.getValue()[0]);
                            if (skip > entity.getMembersAtOdataCount())
                                skip = entity.getMembersAtOdataCount();
                        }
                        break;
                    default:
                        // REQ: may support $expand, $filter, and $select query parameters
                        unknownParameters.add(key);
                        break;
                }
            } else {
                switch(key) {
                    case "excerpt":
                    case "only":
                        // REQ: Shall return HTTP 400 bad request status code for any query parameters
                        // that contain values that are invalid or values applied to the query parameters
                        // without defined values, such as excerpt, only
                        if ((parameter.getValue().length != 1) || (!parameter.getValue()[0].isEmpty())) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Bad Request");
                        }
                        if (key.equals("only")) only = true;
                        if (key.equals("excerpt")) excerpt = true;
                        break;
                    default:
                        // REQ: Shall ignore unknown or unsupported query parameters that
                        // do not begin with $
                        break;
                }
            }
        }
        if (!unknownParameters.isEmpty()) {
            // REQ: shall return a 501 not implemented status code for any unsupported
            // query parameters that start with $.  An extended error that
            // indicates unsupported query parameters for this resource
            RedfishError error = redfishErrorResponseService.getErrorMessage(
                    "Base","QueryNotSupported",new ArrayList<>(), new ArrayList<>());
            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(error);
        }

        if ((parameters.containsKey("only"))&&(parameters.entrySet().size()>1)) {
            // REQ: Services should return the HTTP 400 Bad Request with the QueryCombinationInvalid message from the
            // base message registry if 'only' is being combined with other query parameters.
            RedfishError error = redfishErrorResponseService.getErrorMessage(
                    "Base","QueryCombinationInvalid",new ArrayList<>(), new ArrayList<>());
            return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(error);
        }

        // Check for special case - there is only one member left, and only is specified
        //if ((entity.getMembersAtOdataCount() == 1) && (parameters.containsKey("only"))) {
/* TODO - redo this  code to use RedfishObject collection search
            // Parse the URI to determine if it is local or remote
            String refUri = entity.getMembers().get(0).getAtOdataId();

            // attempt to get the resource from the related database
            RedfishObject refObject = objectRepository.getFirstByUri(refUri);
            if (refObject != null) {
                // object found in local repository.
                return ResponseEntity.ok().contentType(MediaType.APPLICATION_JSON).body(
                        Helpers.createJsonStringFromObject(refObject));
            }

            // if the reference is for an external entity, return the entity
            return Helpers.getExternalResourceFromUri(request, refUri);

 */
        //}

        // REQ: Services shall process query parameters in this order: $filter, $skip, $top,
        // apply server-side pagination, $expand, excerpt, $select
        List<Document> members = entity.getMembers();
        if (skip+top<members.size()) {
            entity.setMembersAtOdataNextLink(uri+"?$skip="+Long.toString(skip+top));
        } else {
            entity.setMembersAtOdataNextLink(null);
        }
        // skip the first n members in the collection
        for (int i=0;i<skip;i++) {
            if (!members.isEmpty()) members.remove(0);
        }
        // show only the top m members in the collection
        while (members.size()>top) members.remove(top);
        entity.setMembers(members);

        // remove null values and values that begin with _
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        String json = "{}";
        // remove any keys that start with underscore character
        entity.remove("_odata_id");
        entity.remove("_odata_type");
        entity.remove("_id");
        String etag = entity.getAtOdataEtag();
        entity.put("@odata.etag",entity.getAtOdataEtag());
        entity.remove("_odata_etag");

        nullWriteOnlyValues(entity);
        try {
            json = mapper.writeValueAsString(entity);
        } catch (Exception ignored) {
        }

        // here if the request is valid - convert the POJO to a clean JSON string and return the results
        // within the body of the HTTP response.
        return ResponseEntity.ok().eTag(etag).contentType(MediaType.APPLICATION_JSON).body(json);
    }

    // onPostCheckForExistence()
    //
    // This method is called during an HTTP post request after initial payload has been validated against the schema.
    // It can be assumed that the payload has all required fields for onCreate, but other required fields may be missing.
    // This method checks to see if any other instances of this object exist in the database.
    // If a duplicate is found, the method returns a RedfishError indicating that a duplicate record has been found
    // otherwise, null is returned.
    //
    // The default behavior of this function is to return null.  Objects that extend this class should perform
    // whatever behavior is appropriate for their class.
    //
    // parameters:
    //    RedfishObject obj -- the object to be posted
    //    HttpServletRequest request -- the post request that was received
    //    CachedSchema schema -- the related schema object for the posted data
    //
    // returns:
    //    RedfishError describing the issue, otherwise null
    //
    protected RedfishError onPostCheckForExistence(RedfishObject obj, HttpServletRequest request, CachedSchema schema) {
        return null;
    }

    // onPostCompleteMissingFields()
    //
    // This method is called during an HTTP post request after initial payload has been validated against the schema.
    // It can be assumed that the payload has all required fields for onCreate, but other required fields may be missing.
    // This method completes field data for any required fields and the updated redfish object is returned.
    //
    // The default behavior of this function is to complete the @odata.id, id, and Name fields.  @odata.type has
    // already been completed. Objects that extend this class should update any other required fields.
    //
    // parameters:
    //    RedfishObject obj -- the object to be posted
    //    HttpServletRequest request -- the post request that was received
    //    CachedSchema schema -- the related schema object for the posted data
    //
    // returns:
    //    RedfishObject with updated fields
    //
    protected RedfishObject onPostCompleteMissingFields(RedfishObject obj, HttpServletRequest request, CachedSchema schema) {
        RedfishObject result = new RedfishObject();
        result.putAll(obj);

        // Always overwrite the @odata.id and Id fields with a unique identifier
        String uuid = UUID.randomUUID().toString();
        String uri = request.getRequestURI();
        if (!uri.endsWith("/Members")) {
            uri = uri.replace("/Members","");
        }
        result.setAtOdataId(uri+"/"+uuid);
        result.setId(uuid);

        if ((!result.containsKey("Name")) || (result.getName().isEmpty())) {
            String name = result.getAtOdataType().replace("#","").split("\\.")[0];
            name = name + " " + uuid;
            result.setName(name);
        }
        return result;
    }

    // onPostCreationChecks()
    //
    // This method checks the validity of the provided data during a POST operation.
    // It can be assumed that the payload has all required fields populated.
    // This method checks field values against service requirements to make sure the object is valid.
    //
    // The default behavior of this is to return null (no error). Objects that extend this class should
    // override this behavior to meet the needs of their specific object type.
    //
    // parameters:
    //    RedfishObject obj -- the object to be posted
    //    HttpServletRequest request -- the post request that was received
    //    CachedSchema schema -- the related schema object for the posted data
    //
    // returns:
    //    RedfishError if errors are found, otherwise null
    //
    protected RedfishError onPostCreationChecks(RedfishObject ignoredObj, HttpServletRequest ignoredRequest, CachedSchema ignoredSchema) {
        return null;
    }

    protected void onPostAfterCreation(RedfishObject ignoredObj, HttpServletRequest ignoredRequest, CachedSchema ignoredSchema) {
    }

    protected ResponseEntity<?> onPostUpdateResponse(RedfishObject obj, HttpServletRequest request, ResponseEntity<?> response) {
        return response;
    }

    // actionAsyncHandler
    // This method is called by the task service to handle the particular action.  Default behavior does nothing.
    //
    // obj - the parameters passed to the action from the caller.
    // uri - the uri of the action call
    // request - the complete request that invoked the action
    // taskId - the taskId that will be associated with this action if it is not completed quickly
    // taskService - the task service that invoked this method call.
    //
    // returns - a response to be returned to the calling client
    public ResponseEntity<?> actionAsyncHandler(RedfishObject obj, String uri, HttpServletRequest request, String taskId, TaskService taskService) {
        // for testing purposes - wait 10 seconds for completion
        try {
            sleep(10000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return ResponseEntity
                .status(HttpStatus.ACCEPTED)
                .contentType(MediaType.APPLICATION_JSON)
                .body("{}");
    }

    // onActionAdditionalParameterChecking()
    // This method is called after an action's parameters have been checked against the schema (or actionInfo) to
    // perform any additional checks.  Scenarios when this might be needed are when there are interdependencies between
    // parameters or between parameters and the configuration of the associated resource.  This method is intended to be
    // overridden by any object controller classes that need additional parameter checks.  The default behavior is to
    // do nothing.
    //
    // parameters - the parameters passed as part of this action request.
    // uri - the uri of the action request.
    // request - the request that was made.
    //
    // returns:
    // a list of redfish errors associated with the parameter checks.  An empty list of no errors are found.
    protected List<RedfishError> onActionAdditionalParameterChecking(RedfishObject obj, String uri, HttpServletRequest request) {
        return new ArrayList<RedfishError>();
    }

    // postHandleActions()
    // This method is called when a post is made to a valid Action uri.  The parameters have already been checked
    // for validity using the Action's definition and/or ActionInfo.
    //
    // because events can be long-running, this function creates an async wrapper and handles task creation if the
    // underlying task takes too long to complete.
    protected ResponseEntity<?> postHandleActions(RedfishObject parameters, String uri, HttpServletRequest request) {
        final long taskWaitTime = 2;  // the maximum amount of seconds to wait for a task to complete
        final long taskRetryTime = 2; // the retry time for the task

        // perform any additional parameter checking for this action
        List<RedfishError> errors = onActionAdditionalParameterChecking(parameters, uri, request);
        if (!errors.isEmpty()) {
            RedfishError errResult = redfishErrorResponseService.getErrorMessage("Base","GeneralError", new ArrayList<>(), new ArrayList<>());
            errResult.getError().getAtMessageExtendedInfo().clear();
            for (RedfishError err: errors) {
                errResult.getError().getAtMessageExtendedInfo().addAll(err.getError().getAtMessageExtendedInfo());
            }
            return ResponseEntity
                    .status(HttpStatus.BAD_REQUEST)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(errResult);
        }

        // the start time for the task.
        OffsetDateTime startTime = OffsetDateTime.now();

        // create a task UUID - it might not get used, but we need its ID value before we start
        String taskID = UUID.randomUUID().toString();

        // Permit either the exception handler or the asynchronous task to access the database, but not both
        Semaphore dbSemaphore = new Semaphore(1);

        // create an asynchronous task instance
        CompletableFuture<ResponseEntity<?>> future =
                taskService.actionAsyncHandler(this, parameters, uri, request, taskID, taskService, dbSemaphore);

        try {
            ResponseEntity<?> result = future.get(taskWaitTime, TimeUnit.SECONDS);

            // here if the task completed before timing out
            return result;
        } catch (TimeoutException e) {
            if (dbSemaphore.tryAcquire()) {
                // here if the task did not complete during the timeout period - create a task and send the response
                HttpHeaders responseHeaders = new HttpHeaders();
                RedfishObject task = taskService.createTaskForAsyncOperation(startTime, taskID);
                taskList.put("taskId", future);
                responseHeaders.set("Location", task.get("TaskMonitor").toString());
                responseHeaders.set("Retry-After", taskRetryTime + " seconds");
                dbSemaphore.release();
                return ResponseEntity.status(HttpStatus.ACCEPTED).headers(responseHeaders).body(task);
            }
            // Handle the condition where the task completed at the same instant that a timeout happened.
            // return the result of the task
            ResponseEntity<?> result = future.getNow(null);
            while (result !=null) result = future.getNow(null);
            return result;
        } catch (Exception e)  {
            // here if the task through an unexpected exception
            return ResponseEntity
                    .status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body("{}");
        }
    }

    @PostMapping(value = "")
    // The function body will only be entered if the user has proper permissions for
    // posting and the provided redfish object meets the minimum criteria for creation
    // as determined by validation against its schema.
    // NOTE: POST is only supported for resource collections.
    public ResponseEntity<?> post(@ValidRedfishObject RedfishObject obj, HttpServletRequest request) {
        // if this is a post for an action, handle it separately
        if (request.getRequestURI().contains("/Actions/")) {
            return postHandleActions(obj, request.getRequestURI(), request);
        }

        // the privilege table maps all acceptable URIs to their Entities and Privileges.  Use this lookup to
        // find the associated entity type for this request.
        String schemaClass = privilegeTableService.getEntityTypeFromUri(request.getRequestURI().replace("/Members",""));
        assert schemaClass != null; // this will happen if there is no entry for the class in the privilege table

        // return an error if the record is not insertable
        if (!schemaService.isInsertable(schemaClass)) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("");
        }

        // get the schema from the object - the odata id field should hold the value
        // odata.type will be of the form of either #TYPE.version.TYPE, or #TYPE.TYPE
        String odatatype = obj.getAtOdataType();
        String type = odatatype.replace("#","").split("\\.")[0];
        String source = odatatype.replace("#","");
        source = source.substring(0,source.length()-type.length());
        source = source + "json";

        // get the schema associated with the source
        CachedSchema schema = schemaService.getFromSource(source);

        // check to see if the resource already exists.  If so, send an error response
        RedfishError error = onPostCheckForExistence(obj,request, schema);
        if (error!=null) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
        }

        // check for any object-specific issues that might exist
        error = onPostCreationChecks(obj, request, schema);
        if (error!=null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
        }

        // update any missing fields
        RedfishObject updatedObj = onPostCompleteMissingFields(obj, request, schema);

        // set the _odata_type and _odata_id fields prior to writing.
        updatedObj.put("_odata_type",updatedObj.getAtOdataType().replace("#","").split("\\.")[0]);
        updatedObj.put("_odata_id",updatedObj.getAtOdataId());

        objectRepository.save(updatedObj);

        // perform any tasks that must be completed after posting the new object
        onPostAfterCreation(updatedObj, request, schema);

        // remove null values and values that begin with _
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        String json = "{}";

        ResponseEntity<?> response = ResponseEntity
                .status(HttpStatus.CREATED)
                .contentType(MediaType.APPLICATION_JSON).body("{}");
        response = onPostUpdateResponse(updatedObj, request, response);

        // remove any keys that start with underscore character
        updatedObj.remove("_odata_id");
        updatedObj.remove("_odata_type");
        updatedObj.remove("_id");
        String etag = updatedObj.getAtOdataEtag();
        updatedObj.put("@odata.etag",etag);
        updatedObj.remove("_odata_etag");

        // remove any write-only values
        nullWriteOnlyValues(updatedObj);

        try {
            json = mapper.writeValueAsString(updatedObj);
        } catch (Exception ignored) {
        }
        String uri = updatedObj.getAtOdataId();
        HttpHeaders headers = new HttpHeaders();
        headers.addAll(response.getHeaders());
        headers.add("Location", uri);

        return ResponseEntity
                .status(response.getStatusCode())
                .headers(headers)
                .eTag(etag)
                .contentType(MediaType.APPLICATION_JSON)
                .body(json);
    }

    // onPatchPreWriteChecks()
    //
    // This method checks the validity of the modified object for a PATCH operation.
    //
    // The default behavior of this is to return null (no error). Objects that extend this class should
    // override this behavior to meet the needs of their specific object type.
    //
    // parameters:
    //    RedfishObject obj -- the object to be written back
    //    HttpServletRequest request -- the post request that was received
    //
    // returns:
    //    RedfishError if errors are found, otherwise null
    //
    protected List<RedfishError> onPatchPreWriteChecks(RedfishObject ignoredObj, HttpServletRequest ignoredRequest) {
        return null;
    }

    protected void onPatchPostWrite(RedfishObject ignoredObj, HttpServletRequest ignoredRequest) {
    }
    @PatchMapping(value = "")
    public ResponseEntity<?> patch(@ValidRedfishObject RedfishObject obj, HttpServletRequest request) {
        // assume that at this point the payload has already been validated against the schema related to this url
        // load the database entry to be patched
        String uri = request.getRequestURI();
        RedfishObject entity = objectRepository.findFirstWithQuery(Criteria
                .where("_odata_id").is(uri));

        if (entity == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("");
        }

        String ifMatch = request.getHeader("If-Match");
        String ifNoneMatch = request.getHeader("If-None-Match");
        if (ifMatch!=null) {
            ifMatch = ifMatch.replace("\"", "");
            if ((!ifMatch.equals("*")) && (!entity.getAtOdataEtag().equals(ifMatch))) {
                // here if the precondition was not met
                return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).body("");
            }
        }
        if (ifNoneMatch!=null) {
            ifNoneMatch = ifNoneMatch.replace("\"", "");
            if ((ifNoneMatch.equals("*"))||(entity.getAtOdataEtag().equals(ifNoneMatch))) {
                // the precondition failed - there should be no matches for this to proceed.
                return ResponseEntity.status(HttpStatus.NOT_MODIFIED).body("");
            }
        }

        // step 1: remove read-only fields from the requested changes, creating errors as we go
        List<RedfishError> result = removeReadOnlyValues(obj);

        // check to see if there are any fields left in the requested changes
        if (obj.isEmpty()) {
            // If all properties in the update request are read-only, unknown, or unsupported, but the resource can be
            // updated, the service shall return the HTTP 400 Bad Request status code and an error response with
            // messages that show the non-updatable properties.
            RedfishError errResult = redfishErrorResponseService.getErrorMessage("Base","GeneralError", new ArrayList<>(), new ArrayList<>());
            errResult.getError().getAtMessageExtendedInfo().clear();
            for (RedfishError err: result) {
                errResult.getError().getAtMessageExtendedInfo().addAll(err.getError().getAtMessageExtendedInfo());
            }
            return ResponseEntity
                    .status(HttpStatus.BAD_REQUEST)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(errResult);
        }

        // there are still non-null fields left to change - make the changes to the payload
        entity.update(obj);

        // perform class-specific checks before writing the changes
        List<RedfishError> additionalErrors = onPatchPreWriteChecks(entity, request);
        if ((additionalErrors != null) && (!additionalErrors.isEmpty())) {
            RedfishError errResult = redfishErrorResponseService.getErrorMessage("Base","GeneralError", new ArrayList<>(), new ArrayList<>());
            errResult.getError().getAtMessageExtendedInfo().clear();
            for (RedfishError err: result) {
                errResult.getError().getAtMessageExtendedInfo().addAll(err.getError().getAtMessageExtendedInfo());
            }
            for (RedfishError err: additionalErrors) {
                errResult.getError().getAtMessageExtendedInfo().addAll(err.getError().getAtMessageExtendedInfo());
            }
            return ResponseEntity
                    .status(HttpStatus.BAD_REQUEST)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(errResult);
        }

        // write back the changes
        objectRepository.update(entity);

        // perform any activities after patch has occurred
        onPatchPostWrite(entity, request);

        // return the result with the proper response code
        if (!result.isEmpty()) {
            entity.put("@Message.ExtendedInfo:",result);
        }
        // remove null values and values that begin with _
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        String json = "{}";
        // remove any keys that start with underscore character
        entity.remove("_odata_id");
        entity.remove("_odata_type");
        entity.remove("_id");
        String etag = entity.getAtOdataEtag();
        entity.put("@odata.etag",entity.getAtOdataEtag());
        entity.remove("_odata_etag");

        // null any write-only values
        nullWriteOnlyValues(entity);

        try {
            json = mapper.writeValueAsString(entity);
        } catch (Exception ignored) {
        }
        return ResponseEntity
                .status(HttpStatus.OK)
                .eTag(etag)
                .contentType(MediaType.APPLICATION_JSON)
                .body(json);
    }

    protected void onDeleteRemoveSubordinates(RedfishObject ignoredObject, HttpServletRequest ignoredRequest) {
    }

    protected boolean isDeleteAllowed(RedfishObject ignoredObject, HttpServletRequest ignoredRequest) {
        return true;
    }

    @DeleteMapping(value="")
    public ResponseEntity<?> delete(HttpServletRequest request) {
        String uri = request.getRequestURI();

        // the privilege table maps all acceptable URIs to their Entities and Privileges.  Use this lookup to
        // find the associated entity type for this request.
        String schemaClass = privilegeTableService.getEntityTypeFromUri(uri);
        assert schemaClass != null; // this will happen if there is no entry for the class in the privilege table

        // return an error if the record is not deletable
        if (!schemaService.isDeletable(schemaClass)) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("");
        }

        RedfishObject entity = objectRepository.findFirstWithQuery(Criteria
                .where("_odata_id").is(uri));
        if (entity==null) {
            // return 404 error - object not found
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("");
        }

        if (!isDeleteAllowed(entity, request)) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(redfishErrorResponseService.getErrorMessage(
                            "Base",
                            "ResourceCannotBeDeleted",
                            new ArrayList<>(),
                            new ArrayList<>()));
        }

        // attempt to delete any subordinates first
        onDeleteRemoveSubordinates(entity, request);

        // now remove the entity
        objectRepository.delete(entity);

        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        String json = "{}";
        // remove any keys that start with underscore character
        entity.remove("_odata_id");
        entity.remove("_odata_type");
        entity.remove("_id");
        entity.put("@odata.etag",entity.getAtOdataEtag());
        entity.remove("_odata_etag");

        // Replace any write-only content with nulls
        nullWriteOnlyValues(entity);

        try {
            json = mapper.writeValueAsString(entity);
        } catch (Exception ignored) {
        }

        return ResponseEntity
                .status(HttpStatus.OK)
                .contentType(MediaType.APPLICATION_JSON)
                .body(json);
    }
}

