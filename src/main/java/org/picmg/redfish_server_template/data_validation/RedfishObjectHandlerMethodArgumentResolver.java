package org.picmg.redfish_server_template.data_validation;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.TextNode;
import org.bson.Document;
import org.picmg.redfish_server_template.RFmodels.Autogenerated.RedfishError;
import org.picmg.redfish_server_template.RFmodels.custom.CachedSchema;
import org.picmg.redfish_server_template.RFmodels.custom.PrivilegeTableEntry;
import org.picmg.redfish_server_template.RFmodels.custom.RedfishObject;
import org.picmg.redfish_server_template.repository.RedfishObjectRepository;
import org.picmg.redfish_server_template.services.Helpers;
import org.picmg.redfish_server_template.services.PrivilegeTableService;
import org.picmg.redfish_server_template.services.RedfishErrorResponseService;
import org.picmg.redfish_server_template.services.SchemaService;
import org.springframework.core.MethodParameter;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.security.authorization.AuthorizationDecision;
import org.springframework.stereotype.Service;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;

import javax.servlet.http.HttpServletRequest;
import java.math.BigDecimal;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.*;

@Service
public class RedfishObjectHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver {
    private final ObjectMapper objectMapper;

    private final RedfishErrorResponseService redfishErrorResponseService;

    private final PrivilegeTableService privilegeTableService;

    private final SchemaService schemaService;

    private final RedfishObjectRepository objectRepository;

    // The constructor for this handler.  One instance of this object is created during the creation phase of
    // the server.
    public RedfishObjectHandlerMethodArgumentResolver(ObjectMapper objectMapper, PrivilegeTableService privilegeTableService, RedfishErrorResponseService redfishErrorResponseService, SchemaService schemaService, RedfishObjectRepository objectRepository) {
        this.objectMapper = objectMapper;
        this.privilegeTableService = privilegeTableService;
        this.redfishErrorResponseService = redfishErrorResponseService;
        this.schemaService = schemaService;
        this.objectRepository = objectRepository;
    }

    private boolean checkAgainstSchemaTypeHelper(String type, JsonNode data) {
        switch (type) {
            case "array":
                if (!data.isArray()) return false;
                break;
            case "boolean":
                if (!data.isBoolean()) return false;
                break;
            case "integer":
                if (!data.isIntegralNumber()) return false;
                break;
            case "number":
                if ((!data.isFloatingPointNumber()) && (!data.isIntegralNumber())) return false;
                break;
            case "null":
                if (!data.isNull()) return false;
                break;
            case "object":
                if (!data.isObject()) return false;
                break;
            case "string":
                if (!data.isTextual()) return false;
                break;
            default:
                // unknown type
                return false;
        }
        return true;
    }
    private boolean checkAgainstSchemaType(JsonNode type, JsonNode data) {
        if (!type.isArray()) {
            return checkAgainstSchemaTypeHelper(type.asText(),data);
        }
        Iterator<JsonNode> it = type.elements();
        while (it.hasNext()) {
            if (checkAgainstSchemaTypeHelper(it.next().asText(),data)) return true;
        }
        return false;
    }

    private boolean checkAgainstEnum(Object enumObj, JsonNode data) {
        // enumerated values must be text
        if (!data.isTextual()) return false;
        // enumeration must be a list of values
        if (!(enumObj instanceof ArrayNode)) return false;
        for (Object enumCase: ((ArrayNode)enumObj)) {
            // return true if object value is in the enumeration.
            if (Objects.equals(data.toString(), enumCase.toString())) return true;
        }
        return false;
    }
    private boolean checkAgainstSchemaFormats(String format, JsonNode data) {
        if (!data.isTextual()) return false;
        switch (format) {
            case "date":
                return data.textValue().matches("^(\\d{4}(-\\d\\d){2})$");
            case "date-time":
                return data.textValue().matches("^(\\d{4}(-\\d\\d){2})[tT]?((\\d\\d:){1,2}(\\d\\d)?(.\\d{3})?([zZ]|[+-](\\d\\d):(\\d\\d)))?$");
            case "time":
                return data.textValue().matches("^((\\d\\d:){1,2}(\\d\\d)?(.\\d{3})?([zZ]|[+-](\\d\\d):(\\d\\d)))?$");
            case "uri":
            case "uri-reference":
                try {
                    new URI(data.textValue());
                } catch (URISyntaxException e) {
                    return false;
                }
                return true;
            case "email":
                return data.textValue().matches("^([\\w!#$%&‘*+–/=?^_`{|}~]+(\\.[\\w!#$%&‘*+–/=?^_`{|}~])*)+@([\\w-]+\\.)*([\\w-])+$");
            case "hostname":
                return data.textValue().matches("^([\\w-]+\\.)*([\\w-])+$");
            case "ipv4":
                return data.textValue().matches("^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");
            case "ipv6":
                return data.textValue().matches("^((([0-9A-Fa-f]{1,4}:){1,6}:)|(([0-9A-Fa-f]{1,4}:){7}))([0-9A-Fa-f]{1,4})$");
            case "uuid":
                return data.textValue().matches("[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}");
            default:
                // unknown type
                return false;
        }
    }

    private List<RedfishError> validateAgainstJsonSchema(
            JsonNode object,
            String schemaRef,
            String callingParam, boolean post) throws JsonProcessingException {
        ArrayList<RedfishError> results = new ArrayList<>();

        // parse the schemaRef
        String schemaSource = schemaRef.split("#")[0];
        String local_address = schemaRef.split("#")[1];

        // get the json schema value from the schema repository
        JsonNode schema = objectMapper.readTree(schemaService.getFromSource(schemaSource).getSchema());

        // attempt to find the referenced fragment of the schema
        if ((!schema.has("definitions"))||(schema.at(local_address).isMissingNode())) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "OperationFailed",
                    new ArrayList<>(),
                    new ArrayList<>(Collections.singletonList(schemaRef))));
            return results;
        }

        for (Iterator<String> it = schema.at(local_address).fieldNames(); it.hasNext(); ) {
            String field = it.next();
            switch (field) {
                case "$ref":
                    String dbRefRef = Helpers.createDatabaseReffromRef(schema.get(local_address).get(field).asText(), schemaSource);
                    List<RedfishError> r2 = validateAgainstJsonSchema(object, dbRefRef, callingParam, post);
                    results.addAll(r2);
                    break;
                case "enum":
                    if (!checkAgainstEnum(schema.at(local_address).get(field),object)) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "PropertyValueTypeError",
                                new ArrayList<>(Arrays.asList(object.textValue(),callingParam)),
                                new ArrayList<>()));
                    }
                    break;
                case "type":
                    if (!checkAgainstSchemaType(schema.at(local_address).get(field),object)) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "PropertyValueTypeError",
                                new ArrayList<>(Arrays.asList(object.textValue(),callingParam)),
                                new ArrayList<>()));
                    }
                    break;
                case "format":
                    if (!checkAgainstSchemaFormats(schema.at(local_address).get(field).asText(),object)) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "PropertyValueIncorrect",
                                new ArrayList<>(Arrays.asList(object.textValue(),callingParam)),
                                new ArrayList<>()));
                    }
                    break;
                case "anyOf":
                    JsonNode anyOf = schema.at(local_address + "/anyOf");
                    if (!anyOf.isArray()) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "OperationFailed",
                                new ArrayList<>(),
                                new ArrayList<>(Collections.singletonList(local_address + "/anyOf"))));
                        return results;
                    }
                    int anyOfIndex = 0;
                    List<RedfishError> subResults = new ArrayList<>();
                    for (JsonNode element : anyOf) {
                        subResults.clear();

                        // the only elements within an anyOf should be a reference to the json definition to check against
                        // loop to find the first of the references that the data validates against
                        if (!element.has("$ref")) {
                            subResults.add(redfishErrorResponseService.getErrorMessage(
                                    "Base",
                                    "OperationFailed",
                                    new ArrayList<>(),
                                    new ArrayList<>(Collections.singletonList(local_address + "/anyOf["+Integer.toString(anyOfIndex)+"]"))));
                            continue;
                        }
                        // split the reference to get the database name and the definition part
                        String newDbRef = Helpers.createDatabaseReffromRef(element.get("$ref").asText(), schemaSource);
                        subResults = validateAgainstJsonSchema(object, newDbRef, callingParam, post);
                        if (subResults.isEmpty()) {
                            // TODO: perform special checking if the database object is a reference to an object pure reference
                            // this checking should be performed if the ref is to #/definitions/idRef"
                            // Check to see if the object exists
                            // Check to see of the object matches against the schema
                            break;
                        }
                        anyOfIndex ++;
                    }
                    if (!subResults.isEmpty()) {
                        // add the results from the last anyOf compare and return the results
                        results.addAll(subResults);
                        return results;
                    }
                    break;
                case "additionalProperties":
                    // see if there are properties other than the required ones in the object
                    JsonNode allowAdditionalProps = schema.at(local_address + "/additionalProperties");
                    if ((allowAdditionalProps.isBoolean()) && (!allowAdditionalProps.asBoolean())) {
                        // get a list of all expected properties
                        JsonNode schemaPropertiesNode = schema.at(local_address + "/properties");
                        if ((schemaPropertiesNode.isMissingNode())||(!schemaPropertiesNode.isObject())) {
                            results.add(redfishErrorResponseService.getErrorMessage(
                                    "Base",
                                    "OperationFailed",
                                    new ArrayList<>(),
                                    new ArrayList<>(Collections.singletonList(local_address + "/additionalProperties"))));
                            return results;
                        }
                        // iterate through list of actual properties in the object to see if there are extras
                        for (Iterator<String> actualPropIt = object.fieldNames(); actualPropIt.hasNext(); ) {
                            String actualProp = actualPropIt.next();
                            if (!schemaPropertiesNode.has(actualProp)) {
                                results.add(redfishErrorResponseService.getErrorMessage(
                                        "Base",
                                        "PropertyUnknown",
                                        new ArrayList<>(Collections.singletonList(actualProp)),
                                        new ArrayList<>()));
                            }
                        }
                    }
                    break;
                case "patternProperties":
                    // TODO: make sure all properties match the given regex pattern
                    break;
                case "properties":
                    JsonNode schemaProperties = schema.at(local_address).get(field);
                    // check every property in the schema against properties in the data
                    for (Iterator<String> propertyIt = schemaProperties.fieldNames(); propertyIt.hasNext(); ) {
                        String propertyName = propertyIt.next();

                        // see if the field exists in the input data
                        if (object.has(propertyName)) {
                            // check the property
                            JsonNode dataField = object.get(propertyName);
                            List<RedfishError> propertyResults = new ArrayList<>();
                            for (Iterator<String> it2 = schemaProperties.get(propertyName).fieldNames(); it2.hasNext(); ) {
                                String propertyRequirement = it2.next();
                                switch (propertyRequirement) {
                                    case "$ref":
                                        String dbRef = Helpers.createDatabaseReffromRef(schemaProperties.get(propertyName).get(propertyRequirement).asText(), schemaSource);
                                        results.addAll(validateAgainstJsonSchema(dataField, dbRef, propertyName, post));
                                        break;
                                    case "enum":
                                        if (!checkAgainstEnum(schemaProperties.get(propertyName).get(propertyRequirement),dataField)) {
                                            results.add(redfishErrorResponseService.getErrorMessage(
                                                    "Base",
                                                    "PropertyValueTypeError",
                                                    new ArrayList<>(Arrays.asList(object.textValue(),callingParam)),
                                                    new ArrayList<>()));
                                        }
                                        break;
                                    case "type":
                                        if (!checkAgainstSchemaType(schemaProperties.get(propertyName).get(propertyRequirement),dataField)) {
                                            results.add(redfishErrorResponseService.getErrorMessage(
                                                    "Base",
                                                    "PropertyValueTypeError",
                                                    new ArrayList<>(Arrays.asList(object.textValue(),propertyName)),
                                                    new ArrayList<>()));
                                        }
                                        break;
                                    case "format":
                                        if (!checkAgainstSchemaFormats(schemaProperties.get(propertyName).get(propertyRequirement).asText(),dataField)) {
                                            results.add(redfishErrorResponseService.getErrorMessage(
                                                    "Base",
                                                    "PropertyValueIncorrect",
                                                    new ArrayList<>(Arrays.asList(object.textValue(),propertyName)),
                                                    new ArrayList<>()));
                                        }
                                        break;
                                    case "readonly":
                                    case "description":
                                    case "longDescription":
                                    case "deletable":
                                    case "insertable":
                                    case "updatable":
                                    case "uris":
                                    case "writeOnly":

                                        // do nothing with this field - not used for validation
                                        break;
                                    case "anyOf":
                                        String addr = local_address + "/properties/"+propertyName+"/anyOf";
                                        JsonNode anyOfProperty = schema.at(addr );
                                        if (!anyOfProperty.isArray()) {
                                            results.add(redfishErrorResponseService.getErrorMessage(
                                                    "Base",
                                                    "OperationFailed",
                                                    new ArrayList<>(),
                                                    new ArrayList<>(Collections.singletonList(local_address + "/anyOf"))));
                                            return results;
                                        }
                                        int anyOfPropertyIndex = 0;
                                        List<RedfishError> subPropertyResults = new ArrayList<>();
                                        for (JsonNode element : anyOfProperty) {
                                            subPropertyResults.clear();

                                            // the only elements within an anyOf should be a reference to the json definition to check against
                                            // or a "type" of "null"
                                            // loop to find the first of the references that the data validates against
                                            if (element.has("$ref")) {
                                                // split the reference to get the database name and the definition part
                                                String newDbRef = Helpers.createDatabaseReffromRef(element.get("$ref").asText(), schemaSource);
                                                subResults = validateAgainstJsonSchema(object, newDbRef, callingParam, post);
                                                if (subResults.isEmpty()) {
                                                    // TODO: perform special checking if the database object is a reference to an object pure reference
                                                    // this checking should be performed if the ref is to #/definitions/idRef"
                                                    // Check to see if the object exists
                                                    // Check to see of the object matches against the schema
                                                    break;
                                                }
                                            } else if (element.has("type")) {
                                                if (element.get("type").textValue().equals("null")) {
                                                    // see if the object has null value for this field - a match is found
                                                    if (!object.hasNonNull(propertyName)) break;
                                                }
                                            } else {
                                                subPropertyResults.add(redfishErrorResponseService.getErrorMessage(
                                                        "Base",
                                                        "OperationFailed",
                                                        new ArrayList<>(),
                                                        new ArrayList<>(Collections.singletonList(local_address + "/anyOf["+Integer.toString(anyOfPropertyIndex)+"]"))));
                                            }
                                            anyOfPropertyIndex ++;
                                        }
                                        if (!subPropertyResults.isEmpty()) {
                                            // add the results from the last anyOf compare and return the results
                                            results.addAll(subPropertyResults);
                                            return results;
                                        }
                                        break;
                                    default:
                                        results.add(redfishErrorResponseService.getErrorMessage(
                                                "Base",
                                                "OperationFailed",
                                                new ArrayList<>(),
                                                new ArrayList<>(Collections.singletonList(local_address + "/properites/"+propertyRequirement))));
                                        return results;
                                }
                            }
                        }
                    }
                    break;
                case "requiredOnCreate":
                    // ignore this key if we ar not posting new data
                    if (!post) break;

                    // see if all the properties required for creation are present
                    JsonNode requiredProps = schema.at(local_address + "/requiredOnCreate");

                    // iterate through list of required properties to make sure they are all present
                    for (Iterator<String> requiredPropIt = requiredProps.fieldNames(); requiredPropIt.hasNext(); ) {
                        String requiredProp = requiredPropIt.next();
                        if (!object.has(requiredProp)) {
                            results.add(redfishErrorResponseService.getErrorMessage(
                                    "Base",
                                    "PropertyMissing",
                                    new ArrayList<>(Collections.singletonList(requiredProp)),
                                    new ArrayList<>()));
                        }
                    }
                    break;
                case "readonly":
                case "description":
                case "longDescription":
                case "deletable":
                case "insertable":
                case "updatable":
                case "uris":
                case "required":
                case "enumDeprecated":
                case "enumDescriptions":
                case "enumLongDescriptions":
                case "enumVersionAdded":
                case "enumVersionDeprecated":
                    // do nothing with this field - not used for validation
                    break;
                default:
                    results.add(redfishErrorResponseService.getErrorMessage(
                            "Base",
                            "OperationFailed",
                            new ArrayList<>(),
                            new ArrayList<>(Collections.singletonList(local_address + "/"+field))));
                    break;
            }
        }
        return results;
    }

    // check to make sure that a given parameter's type matches the one expected in the metadata for the parameter defintion
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkParameterAgainstDataType(String parameterType, JsonNode parameter, String actionName, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        String metadataDataType = parameterDefinition.getString("DataType");
        if (metadataDataType==null) {
            if (!parameterType.equals("String")) {
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterValueTypeError",
                        new ArrayList<>(Arrays.asList(parameter.toString(), parameterName, actionName)),
                        new ArrayList<>()));
            }
            return;
        }
        if ((parameterType.equals("Array"))&&(metadataDataType.endsWith("Array"))) return;
        if (!metadataDataType.equals(parameterType)) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "ActionParameterValueTypeError",
                    new ArrayList<>(Arrays.asList(parameter.toString(), parameterName, actionName)),
                    new ArrayList<>()));
        }
    }

    // check the given parameter against the corresponding parameterDefintion metadata to see that it includes only allowed numeric values
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkStringAgainstAllowableNumbers(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        final String iso8601regex = "^P(?:(\\d+D)|(\\d+D)?T(\\d+H)(\\d+M)?(\\d+(.\\d+)S)?|(\\d+D)?T(\\d+H)?(\\d+M)(\\d+(.\\d+)S)?|(\\d+D)?T(\\d+H)?(\\d+M)?(\\d+(.\\d+)S))$";

        // first, see if the allowable numbers specification is present
        if (!parameterDefinition.containsKey("AllowableNumbers")) return;
        if (!(parameterDefinition.get("AllowableNumbers") instanceof ArrayList)) {
            // here if the metatdata field exists, but it is not an array - this is an internal error
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
        }
        ArrayList<Object> allowableValues = parameterDefinition.get("AllowableNumbers", ArrayList.class);

        // next, verify that the parameter is of the correct format
        if (!parameter.textValue().matches(iso8601regex)) {
            // here if the string is of the wrong format
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "ActionParameterValueFormatError",
                    new ArrayList<>(Arrays.asList(
                            parameter.textValue(),
                            parameterName,
                            actionName
                    )),
                    new ArrayList<>()));
            return;
        }
        Duration parameterDuration = Duration.parse(parameter.textValue());

        // when this metadata specification is applied to stings, it means the parameter value should be interpreted
        // as a duration.  The annotation contains a range of values and an optional step value.  The format is
        // <min>:<max>:<step>
        // if <min> is omitted, the range starts at 0
        // if <step> is omitted, no step is assumed for the supported range
        for (Object allowableValue: allowableValues) {
            String[] valueSpecification = allowableValue.toString().split(":");
            if (valueSpecification.length > 3) continue;
            // check that the parameter is greater than or equal to the minimum value
            if (valueSpecification[0].isEmpty()) {
                // if not specified, the minimum value is 0
                if (parameterDuration.isNegative()) continue;
            } else {
                if (!valueSpecification[0].matches(iso8601regex)) continue;
                if (parameterDuration.compareTo(Duration.parse(valueSpecification[0]))<0) continue;
            }

            if (valueSpecification.length<2) {
                // here if the parameter is greater than the minimum and there is no
                // other part of the specification to match - return
                return;
            }

            // check that the parameter is less than or equal to the minimum value
            if (valueSpecification[1].isEmpty()) {
                // if not specified, there is no maximum value
            } else {
                if (!valueSpecification[1].matches(iso8601regex)) continue;
                if (parameterDuration.compareTo(Duration.parse(valueSpecification[1]))>0) continue;
            }

            if (valueSpecification.length<3) {
                // here if the parameter is greater than the minimum and less than the maximum
                // and there is no other part of the specification to match - return
                return;
            }

            // check that the parameter is located at a valid step
            if (valueSpecification[2].isEmpty()) {
                // if not specified, there is no step
                return;
            } else {
                if (!valueSpecification[2].matches(iso8601regex)) continue;
                Duration step = Duration.parse(valueSpecification[2]);
                if (step.isZero()) continue;
                Duration min = Duration.parse(valueSpecification[0]);

                Duration delta = parameterDuration.minus(min);
                if (step.multipliedBy(delta.dividedBy(step)).compareTo(delta) == 0) {
                    // here if the parameter lies on a step boundary.  This is a match
                    return;
                }
            }
        }
        // no matches have been found - add an error message
        results.add(redfishErrorResponseService.getErrorMessage(
                "Base",
                "ActionParameterValueError",
                new ArrayList<>(Arrays.asList(
                        parameterName,
                        actionName
                )),
                new ArrayList<>()));
    }

    // check the given parameter against the corresponding parameterDefintion metadata to see that it includes only allowed string patterns
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkStringAgainstAllowablePattern(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // first, see if the allowable pattern specification is present
        if (!parameterDefinition.containsKey("AllowablePattern")) return;
        if (!(parameterDefinition.get("AllowablePattern") instanceof String)) {
            // here if the metatdata field exists, but it is not an array - this is an internal error
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
        }
        String pattern = parameterDefinition.get("AllowablePattern", String.class);

        // next, verify that the parameter is of the correct format
        if (!parameter.textValue().matches(pattern)) {
            // here if the string is of the wrong format
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "ActionParameterValueFormatError",
                    new ArrayList<>(Arrays.asList(
                            parameter.textValue(),
                            parameterName,
                            actionName
                    )),
                    new ArrayList<>()));
        }
    }

    // check the given parameter against the corresponding parameterDefintion metadata to see that it includes only allowed string values
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkStringAgainstAllowableValues(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // first, see if the allowable values specification is present
        if (!parameterDefinition.containsKey("AllowableValues")) return;
        if (!(parameterDefinition.get("AllowableValues") instanceof ArrayList)) {
            // here if the metatdata field exists, but it is not an array - this is an internal error
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
        }
        ArrayList<Object> allowableValues = parameterDefinition.get("AllowableValues", ArrayList.class);

        // check for matches
        for (Object allowableValue: allowableValues) {
            if (parameter.textValue().equals(allowableValue.toString())) return;
        }
        // no matches have been found - add an error message
        results.add(redfishErrorResponseService.getErrorMessage(
                "Base",
                "ActionParameterValueError",
                new ArrayList<>(Arrays.asList(
                        parameterName,
                        actionName
                )),
                new ArrayList<>()));
    }

    // check the given parameter against the corresponding parameterDefintion metadata to see that it includes only allowed numeric values
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkNumberAgainstAllowableNumbers(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // first, see if the allowable numbers specification is present
        if (!parameterDefinition.containsKey("AllowableNumbers")) return;
        if (!(parameterDefinition.get("AllowableNumbers") instanceof ArrayList)) {
            // here if the metatdata field exists, but it is not an array - this is an internal error
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
        }
        ArrayList<Object> allowableValues = parameterDefinition.get("AllowableNumbers", ArrayList.class);

        // use bigdecimal format so there is no loss of precision
        BigDecimal parameterValue = parameter.decimalValue();

        for (Object allowableValue: allowableValues) {
            String[] valueSpecification = allowableValue.toString().split(":");
            if (valueSpecification.length > 3) continue;

            // check that the parameter is greater than or equal to the minimum value
            if (valueSpecification[0].isEmpty()) {
                // if not specified, the minimum value is 0
                if (parameterValue.compareTo(BigDecimal.valueOf(0)) < 0) continue;
            } else {
                try {
                    BigDecimal spec = new BigDecimal(valueSpecification[0]);
                    if (parameterValue.compareTo(spec) < 0) continue;
                } catch (Exception ignored) {
                    // problem with numeric conversion - just ignore this comparison and move on to the next
                    continue;
                }
            }

            if (valueSpecification.length<2) {
                // here if the parameter is greater than the minimum and there is no
                // other part of the specification to match - return
                return;
            }

            // check that the parameter is less than or equal to the minimum value
            if (valueSpecification[1].isEmpty()) {
                // if not specified, no maximum value
            } else {
                try {
                    BigDecimal spec = new BigDecimal(valueSpecification[1]);
                    if (parameterValue.compareTo(spec) > 0) continue;
                } catch (Exception ignored) {
                    // problem with numeric conversion - just ignore this comparison and move on to the next
                    continue;
                }
            }

            if (valueSpecification.length<3) {
                // here if the parameter is greater than the minimum and less than the maximum
                // and there is no other part of the specification to match - return
                return;
            }

            // check that the parameter is located at a valid step
            if (valueSpecification[2].isEmpty()) {
                // if not specified, There is no step
            } else {
                try {
                    BigDecimal min = new BigDecimal(valueSpecification[0]);
                    BigDecimal step = new BigDecimal(valueSpecification[2]);
                    BigDecimal delta = parameterValue.subtract(min);
                    if (delta.divideAndRemainder(step)[1].compareTo(BigDecimal.valueOf(0))==0) {
                        // value lies on step boundary
                        return;
                    }
                } catch (Exception ignored) {
                    // problem with numeric conversion - just ignore this comparison and move on to the next
                    results.add(redfishErrorResponseService.getErrorMessage(
                            "Base",
                            "InternalError",
                            new ArrayList<>(),
                            new ArrayList<>()));
                    return;
                }
            }
        }
        // parameter is out of range
        results.add(redfishErrorResponseService.getErrorMessage(
                "Base",
                "ActionParameterValueError",
                new ArrayList<>(Arrays.asList(
                        parameterName,
                        actionName
                )),
                new ArrayList<>()));
    }

    // check the given parameter against the corresponding parameterDefintion metadata to make sure it meets the minimum value requirement
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkNumberAgainstMinimumValue(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // first, see if the MinimumValue specification is present
        if (!parameterDefinition.containsKey("MinimumValue")) return;

        // use bigdecimal format so there is no loss of precision
        BigDecimal parameterValue = parameter.decimalValue();

        try {
            BigDecimal spec = new BigDecimal(parameterDefinition.get("MinimumValue").toString());
            if (parameterValue.compareTo(spec) >=0 ) return;
        } catch (Exception ignored) {
            // problem with numeric conversion
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
            return;
        }
        // no matches have been found - add an error message
        results.add(redfishErrorResponseService.getErrorMessage(
                "Base",
                "ActionParameterValueError",
                new ArrayList<>(Arrays.asList(
                        parameterName,
                        actionName
                )),
                new ArrayList<>()));
    }

    // check the given parameter against the corresponding parameterDefintion metadata to make sure it meets the maximum value requirement
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkNumberAgainstMaximumValue(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // first, see if the MaximumValue specification is present
        if (!parameterDefinition.containsKey("MaximumValue")) return;

        // use bigDecimal format so there is no loss of precision
        BigDecimal parameterValue = parameter.decimalValue();

        try {
            BigDecimal spec = new BigDecimal(parameterDefinition.get("MaximumValue").toString());
            if (parameterValue.compareTo(spec) <=0 ) return;
        } catch (Exception ignored) {
            // problem with numeric conversion
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
            return;
        }
        // no matches have been found - add an error message
        results.add(redfishErrorResponseService.getErrorMessage(
                "Base",
                "ActionParameterValueError",
                new ArrayList<>(Arrays.asList(
                        parameterName,
                        actionName
                )),
                new ArrayList<>()));
    }

    // check the given parameter against the corresponding parameterDefintion metadata to make sure it is a valid object
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkObjectAgainstActionInfo(String actionName, JsonNode jsonNode, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // objects must specify the object data type in the parameter definition
        if ((!parameterDefinition.containsKey("ObjectDataType")) ||
                (!parameterDefinition.getString("ObjectDataType").startsWith("#"))) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
            return;
        }
        String schemaId = parameterDefinition.getString("ObjectDataType");
        String schemaSource = schemaId.substring(0,schemaId.lastIndexOf("."));
        schemaSource = schemaSource.replace("#","") + ".json";
        String schemaClass = schemaId.substring(schemaId.lastIndexOf(".")+1);

        // validate the Json object against the schema
        try {
            List<RedfishError> newResults = validateAgainstJsonSchema(
                    jsonNode,
                    schemaSource + "#/definitions/" + schemaClass,
                    "<unknown>",
                    true);
            results.addAll(newResults);
        } catch (Exception ignored) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
        }
    }

    // check the given parameter against the corresponding parameterDefintion metadata to make each element in the array meets the requirements
    // if an error is encountered, the list of redfish errors in the parameter "results" is updated.
    private void checkArrayValuesAgainstActionInfo(String actionName, JsonNode parameter, String parameterName, Document parameterDefinition, List<RedfishError> results) {
        // check the size of the array
        if (parameterDefinition.containsKey("ArraySizeMinimum")) {
            int minvalue = parameterDefinition.getInteger("ArraySizeMinimum", 0);
            if (parameter.size()<minvalue) {
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterValueFormatError",
                        new ArrayList<>(Arrays.asList(
                                parameter.toString(),
                                parameterName,
                                actionName
                        )),
                        new ArrayList<>()));
            }
        }
        if (parameterDefinition.containsKey("ArraySizeMaximum")) {
            int maxvalue = parameterDefinition.getInteger("ArraySizeMaximum", 0);
            if (parameter.size()>maxvalue) {
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterValueFormatError",
                        new ArrayList<>(Arrays.asList(
                                parameter.toString(),
                                parameterName,
                                actionName
                        )),
                        new ArrayList<>()));
            }
        }

        // here if the array size is in bounds - check each element of the array
        String arrayType = parameterDefinition.getString("DataType");
        arrayType = arrayType.substring(0,arrayType.lastIndexOf("Array"));

        Iterator<JsonNode> elements = parameter.elements();
        int i = 0;
        while (elements.hasNext()) {
            JsonNode givenParam = elements.next();

            switch (arrayType) {
                case "String":
                    if (!givenParam.isTextual()) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "ActionParameterValueFormatError",
                                new ArrayList<>(Arrays.asList(
                                        givenParam.textValue(),
                                        parameterName+"["+i+"]",
                                        actionName
                                )),
                                new ArrayList<>()));
                        continue;
                    }
                    checkStringAgainstAllowableNumbers(actionName, givenParam, parameterName+"["+i+"]", parameterDefinition, results);
                    checkStringAgainstAllowablePattern(actionName, givenParam, parameterName+"["+i+"]", parameterDefinition, results);
                    checkStringAgainstAllowableValues(actionName, givenParam, parameterName+"["+i+"]", parameterDefinition, results);
                    break;
                case "Number":
                    if (!givenParam.isNumber()) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "ActionParameterValueFormatError",
                                new ArrayList<>(Arrays.asList(
                                        givenParam.textValue(),
                                        parameterName+"["+i+"]",
                                        actionName
                                )),
                                new ArrayList<>()));
                        continue;
                    }
                    checkNumberAgainstAllowableNumbers(actionName, givenParam, parameterName+"["+i+"]", parameterDefinition, results);
                    checkNumberAgainstMinimumValue(actionName, givenParam, parameterName, parameterDefinition, results);
                    checkNumberAgainstMaximumValue(actionName, givenParam, parameterName, parameterDefinition, results);
                    break;
                case "Object":
                    if (!givenParam.isObject()) {
                        results.add(redfishErrorResponseService.getErrorMessage(
                                "Base",
                                "ActionParameterValueFormatError",
                                new ArrayList<>(Arrays.asList(
                                        givenParam.textValue(),
                                        parameterName+"["+i+"]",
                                        actionName
                                )),
                                new ArrayList<>()));
                        continue;
                    }
                    checkObjectAgainstActionInfo(actionName, givenParam, parameterName+"["+i+"]", parameterDefinition, results);
                    break;
                default:
                    results.add(redfishErrorResponseService.getErrorMessage(
                            "Base",
                            "InternalError",
                            new ArrayList<>(),
                            new ArrayList<>()));
                    return;
            }
            i++;
        }
    }

    public List<RedfishError> evauateActionParametersAgainstActionInfoParameters(String actionName, JsonNode jsonNode, ArrayList<Document> actionInfoParameters) {
        ArrayList<RedfishError> results = new ArrayList<>();

        for (Document parameterDefinition: actionInfoParameters) {
            if (!parameterDefinition.containsKey("Name")) {
                // invalid parameter definition - all parameters must have a Name
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "InternalError",
                        new ArrayList<>(),
                        new ArrayList<>()));
                return results;
            }
            String parameterName = parameterDefinition.get("Name").toString();

            // see if a corresponding parameter has been given
            if (!jsonNode.has(parameterName)) {
                // if the parameter is not required, move on to the next parameter
                if (!parameterDefinition.getBoolean("Required", false)) continue;

                // otherwise, this is an error
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterMissing",
                        new ArrayList<>(Arrays.asList(actionName, parameterName)),
                        new ArrayList<>()));
                continue;
            }

            // if the parameter has been given, evaluate it against the other metadata in the parameter definition
            JsonNode givenParam = jsonNode.get(parameterName);
            if (givenParam.isBoolean()) {
                checkParameterAgainstDataType("Boolean", givenParam, actionName, parameterName, parameterDefinition, results);
            } else if (givenParam.isTextual()) {
                checkParameterAgainstDataType("String", givenParam, actionName, parameterName, parameterDefinition, results);
                checkStringAgainstAllowableNumbers(actionName, givenParam, parameterName, parameterDefinition, results);
                checkStringAgainstAllowablePattern(actionName, givenParam, parameterName, parameterDefinition, results);
                checkStringAgainstAllowableValues(actionName, givenParam, parameterName, parameterDefinition, results);
            } else if (givenParam.isNumber()) {
                checkParameterAgainstDataType("Number",givenParam, actionName, parameterName, parameterDefinition,results);
                checkNumberAgainstAllowableNumbers(actionName, givenParam, parameterName, parameterDefinition, results);
                checkNumberAgainstMinimumValue(actionName, givenParam, parameterName, parameterDefinition, results);
                checkNumberAgainstMaximumValue(actionName, givenParam, parameterName, parameterDefinition, results);
            } else if (givenParam.isObject()) {
                checkParameterAgainstDataType("Object",givenParam, actionName, parameterName, parameterDefinition,results);
                checkObjectAgainstActionInfo(actionName, givenParam, parameterName, parameterDefinition, results);
            } else if (givenParam.isArray()) {
                checkParameterAgainstDataType("Array",givenParam, actionName, parameterName, parameterDefinition,results);
                checkArrayValuesAgainstActionInfo(actionName, givenParam, parameterName, parameterDefinition, results);
            }
        }

        // check for parameters that are provided but are not defined in the ActionInfo resource
        Iterator<String> it = jsonNode.fieldNames();
        while (it.hasNext()) {
            String fieldname = it.next();

            // attempt to find the field name within the ActionInfo
            boolean found = false;
            for (Document doc:actionInfoParameters) {
                if (!doc.containsKey("Name")) continue;
                if (doc.getString("Name").equals(fieldname)) {
                    found = true;
                    break;
                };
            }
            if (!found) {
                // here if unknown parameter
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterUnknown",
                        new ArrayList<>(Arrays.asList(actionName, fieldname)),
                        new ArrayList<>()));
            }
        }
        return results;
    }

    // This function verifies an action's parameters based on the contents of an ActionItem resource
    // For this service, the only parameters that are allowed are those specified explicitly in the
    // resource.  Additional parameters will be identified as errors.
    //
    // Parameters:
    //    actionName - the name for the action (including the base type)
    //    jsonNode - the json payload for this action request
    //    actionInfoUri - the URI for the ActionInfo resource for this action
    //
    // returns a list of RedifishErrors if there are problems found with the payload.
    // if no issues are found, the list will be empty.
    private List<RedfishError> evaluateActionParamsWithActionInfo(String actionName, JsonNode jsonNode, String actionInfoUri) throws Exception {
        List<RedfishError> results = new ArrayList<>();

        // attempt to get the ActionInfo from the database
        RedfishObject actionInfoObject = objectRepository.findFirstWithQuery(Criteria.where("_odata_id").is(actionInfoUri));
        if (actionInfoObject == null) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InvalidUri",
                    new ArrayList<>(Collections.singletonList(actionInfoUri)),
                    new ArrayList<>()));
            return results;
        }

        // find the parameters key with in the actionInfo resource
        if (!actionInfoObject.containsKey("Parameters") || !(actionInfoObject.get("Parameters") instanceof ArrayList)) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base",
                    "InternalError",
                    new ArrayList<>(),
                    new ArrayList<>()));
            return results;
        }
        ArrayList<Document> actionInfoParameters = actionInfoObject.get("Parameters", ArrayList.class);
        return evauateActionParametersAgainstActionInfoParameters(actionName, jsonNode, actionInfoParameters);
    }

    // This function verifies an action's parameters based on the older mechanism of specifying
    // @Redfish.AllowableValues annotations in the body of the resource that defines the action.
    // For this service, the only parameters that are allowed are those specified explicitly in the
    // resource.  All parameters are assumed to be required.
    //
    // Parameters:
    //    actionName - the name for the action (including the base type)
    //    jsonNode - the json payload for this action request
    //    schema - a json representation of the base object's schema
    //    actionInfoUri - the action definition from the resource itself.
    //
    // returns a list of RedifishErrors if there are problems found with the payload.
    // if no issues are found, the list will be empty.
    private List<RedfishError> evaluateActionParamsWithSchemaDefinition(String actionName, JsonNode jsonNode, JsonNode schema, Document resourceActionDefinition) throws Exception {
        List<RedfishError> results = new ArrayList<>();

        // check provided parameters against the schema for this resource
        // first, does the actions section even exist in the schema?
        if (!schema.has("definitions")) {
            // action does not exist for the base resource
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base", "OperationFailed",
                    new ArrayList<>(), new ArrayList<>())
            );
            return results;
        }
        JsonNode schemaDefinitions = schema.get("definitions");
        if (!schemaDefinitions.has("Actions")) {
            // action does not exist for the base resource
            results.add(redfishErrorResponseService.getErrorMessage(
                "Base", "ActionNotSupported",
                    new ArrayList<>(Collections.singletonList(actionName)), new ArrayList<>())
                    );
            return results;
        }
        JsonNode schemaActions = schemaDefinitions.get("Actions");
        // The actions section exists in the schema.  Does the properties field exist?
        if (!schemaActions.has("properties")) {
            // action does not exist for the base resource
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base", "ActionNotSupported",
                    new ArrayList<>(Collections.singletonList(actionName)), new ArrayList<>())
            );
            return results;
        }
        JsonNode schemaActionProps = schemaActions.get("properties");
        // The actions section exists in the schema.  Does the action exist?
        if (!schemaActionProps.has("#"+actionName)) {
            // action does not exist for the base resource
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base", "ActionNotSupported",
                    new ArrayList<>(Collections.singletonList(actionName)), new ArrayList<>())
            );
            return results;
        }
        JsonNode schemaActionDef = schemaActionProps.get("#"+actionName);

        JsonNode schemaParametersObj = null;
        // The definition for the action has been found - there should either be a field called "parameters" that
        // contains fields for each of the parameters to check, or there should be a field called $ref that references
        // a fragment within the definitions section of the schema for the definition of the action
        if (schemaActionDef.has("parameters")) {
            schemaParametersObj = schemaActionDef.get("parameters");
        } else if (schemaActionDef.has("$ref")) {
            // here if the definition points to a schema fragment
            // assume the fragment is within this schema file, within the definitions section
            String definitionName = schemaActionDef.get("$ref").asText();
            definitionName = definitionName.substring(definitionName.lastIndexOf("/")+1);
            if (!schemaDefinitions.has(definitionName)) {
                // name of definition fragment not found
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base", "OperationFailed",
                        new ArrayList<>(), new ArrayList<>()));
                return results;
            }
            if (schemaDefinitions.get(definitionName).has("parameters")) {
                schemaParametersObj = schemaDefinitions.get(definitionName).get("parameters");
            }
        }
        // check to see if no parameters were found
        if (schemaParametersObj==null) {
            results.add(redfishErrorResponseService.getErrorMessage(
                    "Base", "OperationFailed",
                    new ArrayList<>(), new ArrayList<>()));
            return results;
        }

        // loop through list of parameters the required parameters are present
        for (Iterator<String> it = schemaParametersObj.fieldNames(); it.hasNext(); ) {
            String paramName = it.next();

            boolean required = false;
            String paramType = "string";
            if (schemaParametersObj.get(paramName).has("requiredParameter")) {
                required = schemaParametersObj.get(paramName).get("requiredParameter").asBoolean(false);
            }
            if (schemaParametersObj.get(paramName).has("type")) {
                paramType = schemaParametersObj.get(paramName).get("type").asText("string");
            }

            if ((!jsonNode.has(paramName))&&(required)) {
                // this is an error - a required parameter is missing
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterMissing",
                        new ArrayList<>(Arrays.asList(actionName,paramName)),
                        new ArrayList<>()));
                continue;
            }

            // check the type of the parameter against the specified type in the schema
            if ((jsonNode.has(paramName))&&(!checkAgainstSchemaTypeHelper(paramType,jsonNode.get(paramName)))) {
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterValueTypeError",
                        new ArrayList<>(Arrays.asList(jsonNode.get(paramName).toString(),paramName,actionName)),
                        new ArrayList<>()));
                continue;
            }
        }

        // now check for annotations and verify parameters against them
        for (String key: resourceActionDefinition.keySet()) {
            if (!key.endsWith("@Redfish.AllowableValues")) continue;

            String paramName = key.substring(0,key.length()-24);

            String paramValue = jsonNode.get(paramName).asText();
            // this action might throw an exception if it cannot convert to a list.  The calling function will
            // catch it though.
            ArrayList<String> allowableValues = resourceActionDefinition.get(key, ArrayList.class);
            boolean foundAllowedValue = false;
            for (String allowed: allowableValues) {
                if (allowed.equals(paramValue)) {
                    foundAllowedValue = true;
                    break;
                }
            }
            if (!foundAllowedValue) {
                // The value specified is not an allowed value
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterValueNotInList",
                        new ArrayList<>(Arrays.asList(paramValue,paramName,actionName)),
                        new ArrayList<>()));
            }
        }

        // loop through list of given parameters to see if there are any that are unknown
        Iterator<String> fields = jsonNode.fieldNames();
        while (fields.hasNext()) {
            String paramName = fields.next();
            if (!schemaParametersObj.has(paramName)) {
                results.add(redfishErrorResponseService.getErrorMessage(
                        "Base",
                        "ActionParameterUnknown",
                        new ArrayList<>(Arrays.asList(actionName,paramName)),
                        new ArrayList<>()));
            }
        }

        return results;
    }

    private List<RedfishError> prepareForActionValidation(String uri, JsonNode json) throws Exception {
        List<RedfishError> results = new ArrayList<>();

        // get the base URI
        String baseUri = uri.substring(0, uri.indexOf("/Actions/"));

        // find the base resource from the uri
        RedfishObject baseObject = objectRepository.findFirstWithQuery(Criteria.where("_odata_id").is(baseUri));

        // get the action name
        String actionName = uri.substring(uri.indexOf("/Actions/") + 9);

        // see if the action exists within the object
        Document actionsDoc = baseObject.get("Actions", Document.class);;

        // see if the action exists in the Actions object
        Document actionDefinition = actionsDoc.get("#"+actionName,Document.class);

        // make sure that the action target matches this url
        String targetUri = actionDefinition.get("target",String.class);
        // should this return a resource not found response?
        if (!targetUri.equals(uri)) throw new Exception();

        // load the schema for the base type for this action
        String schemaId = baseObject.getAtOdataType();
        String schemaSource = schemaId.substring(0,schemaId.lastIndexOf("."));
        schemaSource = schemaSource.replace("#","") + ".json";
        String schemaClass = schemaId.substring(schemaId.lastIndexOf(".")+1);
        JsonNode schema = objectMapper.readTree(schemaService.getFromSource(schemaSource).getSchema());

        // here if the target URI matches a valid Action URI - now determine if the URI should be checked
        // using @Redfish and the Schema, or with the ActionInfo semantic.
        if (actionDefinition.containsKey("@Redfish.ActionInfo")) {
            String actionInfoUri = actionDefinition.get("@Redfish.ActionInfo", String.class);
            results = evaluateActionParamsWithActionInfo(actionName, json,actionInfoUri);
        } else {
            // check using the schema and annotations in the resource
            results = evaluateActionParamsWithSchemaDefinition(actionName, json, schema, actionDefinition);
        }
        return results;
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        // verify that the parameter is @ValidRedfishObject
        return parameter.getParameterAnnotation(ValidRedfishObject.class) != null;
    }

    @Override
    // This function overrides the default behavior to resolve an input parameter into an argument.
    // This code is invoked automatically by the spring framework to convert any parameters tagged with the
    // @ValidRedfishObject attributes
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        // get the Name of the redfish object based on the uri of the request.
        HttpServletRequest req = webRequest.getNativeRequest(HttpServletRequest.class);

        assert req != null;  // this should never happen, since this function is called by valid http requests
        String uri = req.getRequestURI();

        if (uri.contains("/Actions/") && (req.getMethod().equals("POST"))) {
            // attempt to validate the action parameters
            List<RedfishError> results = new ArrayList<>();
            try {
                String body = StreamUtils.copyToString(req.getInputStream(), StandardCharsets.UTF_8);
                // convert the body string into a JsonNode object
                JsonNode jsonNode = objectMapper.readTree(body);
                results = prepareForActionValidation(uri, jsonNode);
                if (results.isEmpty()) {
                    // here if everything checks out.  Update the object's odata type to match the type that
                    // the object compared against
                    return objectMapper.treeToValue(jsonNode, parameter.getParameterType());
                }
            } catch (Exception ignored) {
            }
            // an exception has occurred - throw a redfisherror exception
            throw new RedfishValidationException(results);
        }

        // the privilege table maps all acceptable URIs to their Entities and Privileges.  Use this lookup to
        // find the associated entity type for this request.
        String schemaClass = privilegeTableService.getEntityTypeFromUri(uri);
        if (schemaClass == null) {
            // this will happen if there is no entry for the class in the privilege table.
            // This should only occur for posts to Actions
            // throw an exception - no schema has been found for this method
            throw new RedfishValidationException(null);
        }

        // special case - if the type ends in "Collection" and method is a POST, the object type should be what the collection holds,
        // not the collection itself.  For Patch, this change should not be made
        if ((Objects.equals(req.getMethod(), "POST"))&&(schemaClass.endsWith("Collection"))) {
            schemaClass = schemaClass.replace("Collection", "");
        }

        CachedSchema schemaRecord = schemaService.getNewestVersionFromType(schemaClass);
        String schemaSource = schemaRecord.getSource();

        // get the body from the request, interpreted as a UTF_8 string
        String body = StreamUtils.copyToString(req.getInputStream(), StandardCharsets.UTF_8);

        // convert the body string into a JsonNode object
        JsonNode jsonNode = objectMapper.readTree(body);

        // validate the Json object against the schema
        List<RedfishError> results = validateAgainstJsonSchema(
                jsonNode,
                schemaSource+"#/definitions/"+schemaClass,
                "<unknown>",
                Objects.equals(req.getMethod(),"POST"));
        if (results.isEmpty()) {
            // here if everything checks out.  Update the object's odata type to match the type that
            // the object compared against
            ((ObjectNode)jsonNode).set("@odata.type",new TextNode("#" +
                    schemaSource.replace("json","")+schemaClass));
            return objectMapper.treeToValue(jsonNode, parameter.getParameterType());
        }

        throw new RedfishValidationException(results);
    }
}
